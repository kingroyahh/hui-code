// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BattleCommand.proto

#ifndef PROTOBUF_BattleCommand_2eproto__INCLUDED
#define PROTOBUF_BattleCommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BattleCommand_2eproto();
void protobuf_AssignDesc_BattleCommand_2eproto();
void protobuf_ShutdownFile_BattleCommand_2eproto();

class AttackRecord;
class RoundRecord;
class BattleRecord;
class UserCommand;

// ===================================================================

class AttackRecord : public ::google::protobuf::MessageLite {
 public:
  AttackRecord();
  virtual ~AttackRecord();

  AttackRecord(const AttackRecord& from);

  inline AttackRecord& operator=(const AttackRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AttackRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttackRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttackRecord* other);

  // implements Message ----------------------------------------------

  AttackRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttackRecord& from);
  void MergeFrom(const AttackRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool skill = 1;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 1;
  inline bool skill() const;
  inline void set_skill(bool value);

  // optional int32 atk_area_index = 2;
  inline bool has_atk_area_index() const;
  inline void clear_atk_area_index();
  static const int kAtkAreaIndexFieldNumber = 2;
  inline ::google::protobuf::int32 atk_area_index() const;
  inline void set_atk_area_index(::google::protobuf::int32 value);

  // optional int32 atk_pos_index = 3;
  inline bool has_atk_pos_index() const;
  inline void clear_atk_pos_index();
  static const int kAtkPosIndexFieldNumber = 3;
  inline ::google::protobuf::int32 atk_pos_index() const;
  inline void set_atk_pos_index(::google::protobuf::int32 value);

  // optional int32 target_area_index = 4;
  inline bool has_target_area_index() const;
  inline void clear_target_area_index();
  static const int kTargetAreaIndexFieldNumber = 4;
  inline ::google::protobuf::int32 target_area_index() const;
  inline void set_target_area_index(::google::protobuf::int32 value);

  // optional int32 target_pos_index = 5;
  inline bool has_target_pos_index() const;
  inline void clear_target_pos_index();
  static const int kTargetPosIndexFieldNumber = 5;
  inline ::google::protobuf::int32 target_pos_index() const;
  inline void set_target_pos_index(::google::protobuf::int32 value);

  // optional int32 attackTime = 6;
  inline bool has_attacktime() const;
  inline void clear_attacktime();
  static const int kAttackTimeFieldNumber = 6;
  inline ::google::protobuf::int32 attacktime() const;
  inline void set_attacktime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.AttackRecord)
 private:
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_atk_area_index();
  inline void clear_has_atk_area_index();
  inline void set_has_atk_pos_index();
  inline void clear_has_atk_pos_index();
  inline void set_has_target_area_index();
  inline void clear_has_target_area_index();
  inline void set_has_target_pos_index();
  inline void clear_has_target_pos_index();
  inline void set_has_attacktime();
  inline void clear_has_attacktime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool skill_;
  ::google::protobuf::int32 atk_area_index_;
  ::google::protobuf::int32 atk_pos_index_;
  ::google::protobuf::int32 target_area_index_;
  ::google::protobuf::int32 target_pos_index_;
  ::google::protobuf::int32 attacktime_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_BattleCommand_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_BattleCommand_2eproto();
  #endif
  friend void protobuf_AssignDesc_BattleCommand_2eproto();
  friend void protobuf_ShutdownFile_BattleCommand_2eproto();

  void InitAsDefaultInstance();
  static AttackRecord* default_instance_;
};
// -------------------------------------------------------------------

class RoundRecord : public ::google::protobuf::MessageLite {
 public:
  RoundRecord();
  virtual ~RoundRecord();

  RoundRecord(const RoundRecord& from);

  inline RoundRecord& operator=(const RoundRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RoundRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoundRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoundRecord* other);

  // implements Message ----------------------------------------------

  RoundRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoundRecord& from);
  void MergeFrom(const RoundRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.AttackRecord attackRecord = 1;
  inline int attackrecord_size() const;
  inline void clear_attackrecord();
  static const int kAttackRecordFieldNumber = 1;
  inline const ::pb::AttackRecord& attackrecord(int index) const;
  inline ::pb::AttackRecord* mutable_attackrecord(int index);
  inline ::pb::AttackRecord* add_attackrecord();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::AttackRecord >&
      attackrecord() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::AttackRecord >*
      mutable_attackrecord();

  // @@protoc_insertion_point(class_scope:pb.RoundRecord)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::AttackRecord > attackrecord_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_BattleCommand_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_BattleCommand_2eproto();
  #endif
  friend void protobuf_AssignDesc_BattleCommand_2eproto();
  friend void protobuf_ShutdownFile_BattleCommand_2eproto();

  void InitAsDefaultInstance();
  static RoundRecord* default_instance_;
};
// -------------------------------------------------------------------

class BattleRecord : public ::google::protobuf::MessageLite {
 public:
  BattleRecord();
  virtual ~BattleRecord();

  BattleRecord(const BattleRecord& from);

  inline BattleRecord& operator=(const BattleRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BattleRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleRecord* other);

  // implements Message ----------------------------------------------

  BattleRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleRecord& from);
  void MergeFrom(const BattleRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.RoundRecord roundRecord = 1;
  inline int roundrecord_size() const;
  inline void clear_roundrecord();
  static const int kRoundRecordFieldNumber = 1;
  inline const ::pb::RoundRecord& roundrecord(int index) const;
  inline ::pb::RoundRecord* mutable_roundrecord(int index);
  inline ::pb::RoundRecord* add_roundrecord();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::RoundRecord >&
      roundrecord() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::RoundRecord >*
      mutable_roundrecord();

  // optional bool clientLose = 2;
  inline bool has_clientlose() const;
  inline void clear_clientlose();
  static const int kClientLoseFieldNumber = 2;
  inline bool clientlose() const;
  inline void set_clientlose(bool value);

  // @@protoc_insertion_point(class_scope:pb.BattleRecord)
 private:
  inline void set_has_clientlose();
  inline void clear_has_clientlose();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::RoundRecord > roundrecord_;
  bool clientlose_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_BattleCommand_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_BattleCommand_2eproto();
  #endif
  friend void protobuf_AssignDesc_BattleCommand_2eproto();
  friend void protobuf_ShutdownFile_BattleCommand_2eproto();

  void InitAsDefaultInstance();
  static BattleRecord* default_instance_;
};
// -------------------------------------------------------------------

class UserCommand : public ::google::protobuf::MessageLite {
 public:
  UserCommand();
  virtual ~UserCommand();

  UserCommand(const UserCommand& from);

  inline UserCommand& operator=(const UserCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserCommand& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserCommand* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserCommand* other);

  // implements Message ----------------------------------------------

  UserCommand* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserCommand& from);
  void MergeFrom(const UserCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.BattleRecord battleRecord = 1;
  inline int battlerecord_size() const;
  inline void clear_battlerecord();
  static const int kBattleRecordFieldNumber = 1;
  inline const ::pb::BattleRecord& battlerecord(int index) const;
  inline ::pb::BattleRecord* mutable_battlerecord(int index);
  inline ::pb::BattleRecord* add_battlerecord();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::BattleRecord >&
      battlerecord() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::BattleRecord >*
      mutable_battlerecord();

  // @@protoc_insertion_point(class_scope:pb.UserCommand)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::BattleRecord > battlerecord_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_BattleCommand_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_BattleCommand_2eproto();
  #endif
  friend void protobuf_AssignDesc_BattleCommand_2eproto();
  friend void protobuf_ShutdownFile_BattleCommand_2eproto();

  void InitAsDefaultInstance();
  static UserCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// AttackRecord

// optional bool skill = 1;
inline bool AttackRecord::has_skill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttackRecord::set_has_skill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttackRecord::clear_has_skill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttackRecord::clear_skill() {
  skill_ = false;
  clear_has_skill();
}
inline bool AttackRecord::skill() const {
  // @@protoc_insertion_point(field_get:pb.AttackRecord.skill)
  return skill_;
}
inline void AttackRecord::set_skill(bool value) {
  set_has_skill();
  skill_ = value;
  // @@protoc_insertion_point(field_set:pb.AttackRecord.skill)
}

// optional int32 atk_area_index = 2;
inline bool AttackRecord::has_atk_area_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttackRecord::set_has_atk_area_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttackRecord::clear_has_atk_area_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttackRecord::clear_atk_area_index() {
  atk_area_index_ = 0;
  clear_has_atk_area_index();
}
inline ::google::protobuf::int32 AttackRecord::atk_area_index() const {
  // @@protoc_insertion_point(field_get:pb.AttackRecord.atk_area_index)
  return atk_area_index_;
}
inline void AttackRecord::set_atk_area_index(::google::protobuf::int32 value) {
  set_has_atk_area_index();
  atk_area_index_ = value;
  // @@protoc_insertion_point(field_set:pb.AttackRecord.atk_area_index)
}

// optional int32 atk_pos_index = 3;
inline bool AttackRecord::has_atk_pos_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AttackRecord::set_has_atk_pos_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AttackRecord::clear_has_atk_pos_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AttackRecord::clear_atk_pos_index() {
  atk_pos_index_ = 0;
  clear_has_atk_pos_index();
}
inline ::google::protobuf::int32 AttackRecord::atk_pos_index() const {
  // @@protoc_insertion_point(field_get:pb.AttackRecord.atk_pos_index)
  return atk_pos_index_;
}
inline void AttackRecord::set_atk_pos_index(::google::protobuf::int32 value) {
  set_has_atk_pos_index();
  atk_pos_index_ = value;
  // @@protoc_insertion_point(field_set:pb.AttackRecord.atk_pos_index)
}

// optional int32 target_area_index = 4;
inline bool AttackRecord::has_target_area_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AttackRecord::set_has_target_area_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AttackRecord::clear_has_target_area_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AttackRecord::clear_target_area_index() {
  target_area_index_ = 0;
  clear_has_target_area_index();
}
inline ::google::protobuf::int32 AttackRecord::target_area_index() const {
  // @@protoc_insertion_point(field_get:pb.AttackRecord.target_area_index)
  return target_area_index_;
}
inline void AttackRecord::set_target_area_index(::google::protobuf::int32 value) {
  set_has_target_area_index();
  target_area_index_ = value;
  // @@protoc_insertion_point(field_set:pb.AttackRecord.target_area_index)
}

// optional int32 target_pos_index = 5;
inline bool AttackRecord::has_target_pos_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AttackRecord::set_has_target_pos_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AttackRecord::clear_has_target_pos_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AttackRecord::clear_target_pos_index() {
  target_pos_index_ = 0;
  clear_has_target_pos_index();
}
inline ::google::protobuf::int32 AttackRecord::target_pos_index() const {
  // @@protoc_insertion_point(field_get:pb.AttackRecord.target_pos_index)
  return target_pos_index_;
}
inline void AttackRecord::set_target_pos_index(::google::protobuf::int32 value) {
  set_has_target_pos_index();
  target_pos_index_ = value;
  // @@protoc_insertion_point(field_set:pb.AttackRecord.target_pos_index)
}

// optional int32 attackTime = 6;
inline bool AttackRecord::has_attacktime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AttackRecord::set_has_attacktime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AttackRecord::clear_has_attacktime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AttackRecord::clear_attacktime() {
  attacktime_ = 0;
  clear_has_attacktime();
}
inline ::google::protobuf::int32 AttackRecord::attacktime() const {
  // @@protoc_insertion_point(field_get:pb.AttackRecord.attackTime)
  return attacktime_;
}
inline void AttackRecord::set_attacktime(::google::protobuf::int32 value) {
  set_has_attacktime();
  attacktime_ = value;
  // @@protoc_insertion_point(field_set:pb.AttackRecord.attackTime)
}

// -------------------------------------------------------------------

// RoundRecord

// repeated .pb.AttackRecord attackRecord = 1;
inline int RoundRecord::attackrecord_size() const {
  return attackrecord_.size();
}
inline void RoundRecord::clear_attackrecord() {
  attackrecord_.Clear();
}
inline const ::pb::AttackRecord& RoundRecord::attackrecord(int index) const {
  // @@protoc_insertion_point(field_get:pb.RoundRecord.attackRecord)
  return attackrecord_.Get(index);
}
inline ::pb::AttackRecord* RoundRecord::mutable_attackrecord(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RoundRecord.attackRecord)
  return attackrecord_.Mutable(index);
}
inline ::pb::AttackRecord* RoundRecord::add_attackrecord() {
  // @@protoc_insertion_point(field_add:pb.RoundRecord.attackRecord)
  return attackrecord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::AttackRecord >&
RoundRecord::attackrecord() const {
  // @@protoc_insertion_point(field_list:pb.RoundRecord.attackRecord)
  return attackrecord_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::AttackRecord >*
RoundRecord::mutable_attackrecord() {
  // @@protoc_insertion_point(field_mutable_list:pb.RoundRecord.attackRecord)
  return &attackrecord_;
}

// -------------------------------------------------------------------

// BattleRecord

// repeated .pb.RoundRecord roundRecord = 1;
inline int BattleRecord::roundrecord_size() const {
  return roundrecord_.size();
}
inline void BattleRecord::clear_roundrecord() {
  roundrecord_.Clear();
}
inline const ::pb::RoundRecord& BattleRecord::roundrecord(int index) const {
  // @@protoc_insertion_point(field_get:pb.BattleRecord.roundRecord)
  return roundrecord_.Get(index);
}
inline ::pb::RoundRecord* BattleRecord::mutable_roundrecord(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BattleRecord.roundRecord)
  return roundrecord_.Mutable(index);
}
inline ::pb::RoundRecord* BattleRecord::add_roundrecord() {
  // @@protoc_insertion_point(field_add:pb.BattleRecord.roundRecord)
  return roundrecord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::RoundRecord >&
BattleRecord::roundrecord() const {
  // @@protoc_insertion_point(field_list:pb.BattleRecord.roundRecord)
  return roundrecord_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::RoundRecord >*
BattleRecord::mutable_roundrecord() {
  // @@protoc_insertion_point(field_mutable_list:pb.BattleRecord.roundRecord)
  return &roundrecord_;
}

// optional bool clientLose = 2;
inline bool BattleRecord::has_clientlose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleRecord::set_has_clientlose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleRecord::clear_has_clientlose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleRecord::clear_clientlose() {
  clientlose_ = false;
  clear_has_clientlose();
}
inline bool BattleRecord::clientlose() const {
  // @@protoc_insertion_point(field_get:pb.BattleRecord.clientLose)
  return clientlose_;
}
inline void BattleRecord::set_clientlose(bool value) {
  set_has_clientlose();
  clientlose_ = value;
  // @@protoc_insertion_point(field_set:pb.BattleRecord.clientLose)
}

// -------------------------------------------------------------------

// UserCommand

// repeated .pb.BattleRecord battleRecord = 1;
inline int UserCommand::battlerecord_size() const {
  return battlerecord_.size();
}
inline void UserCommand::clear_battlerecord() {
  battlerecord_.Clear();
}
inline const ::pb::BattleRecord& UserCommand::battlerecord(int index) const {
  // @@protoc_insertion_point(field_get:pb.UserCommand.battleRecord)
  return battlerecord_.Get(index);
}
inline ::pb::BattleRecord* UserCommand::mutable_battlerecord(int index) {
  // @@protoc_insertion_point(field_mutable:pb.UserCommand.battleRecord)
  return battlerecord_.Mutable(index);
}
inline ::pb::BattleRecord* UserCommand::add_battlerecord() {
  // @@protoc_insertion_point(field_add:pb.UserCommand.battleRecord)
  return battlerecord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::BattleRecord >&
UserCommand::battlerecord() const {
  // @@protoc_insertion_point(field_list:pb.UserCommand.battleRecord)
  return battlerecord_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::BattleRecord >*
UserCommand::mutable_battlerecord() {
  // @@protoc_insertion_point(field_mutable_list:pb.UserCommand.battleRecord)
  return &battlerecord_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BattleCommand_2eproto__INCLUDED
